#include "feistel.h"
#include <iostream>
#include <iomanip>

int main() {
    // For simulation purposes, generate secrets (as if connecting to the oracle).
    generate_secrets();

    std::cout << "=== Attacker Exploit Simulation ===\n";
    std::cout << "Attempting to recover the secret key via a chosen-plaintext attack.\n";

    // Choose a plaintext with left half = 0 and right half = chosen_R.
    uint32_t chosen_R = 0x12345678;
    uint64_t chosen_plaintext = (static_cast<uint64_t>(0) << 32) | chosen_R;
    std::cout << "[Attacker] Using chosen plaintext: 0x" << std::hex << chosen_plaintext
              << " (L=0, R=0x" << chosen_R << ")\n";

    // After the first round of encryption:
    //   new_L = chosen_R,
    //   new_R = 0 XOR round_function(chosen_R, KEY) = round_function(chosen_R, KEY)
    uint32_t F0 = round_function(chosen_R, KEY);
    std::cout << "[Attacker] Leaked F0 = round_function(0x" << std::hex << chosen_R
              << ", key) = 0x" << F0 << "\n";

    // Rearranging the equation:
    //   F0 = ((chosen_R XOR key) + (chosen_R << 1)) mod 2^32
    // Thus, chosen_R XOR key = (F0 - (chosen_R << 1)) mod 2^32,
    // and so: key = chosen_R XOR (F0 - (chosen_R << 1)).
    uint32_t recovered_key = chosen_R ^ (F0 - (chosen_R << 1));
    std::cout << "[Attacker] Recovered key: 0x" << std::hex << recovered_key << "\n";

    if (recovered_key == KEY) {
        std::cout << "[Attacker] Success! Key correctly recovered.\n";
    } else {
        std::cout << "[Attacker] Failure! Recovered key does not match the actual key.\n";
    }

    // Decrypt the secret flag.
    uint64_t ct_flag = feistel_encrypt(SECRET_FLAG, KEY, false);
    uint64_t decrypted = feistel_decrypt(ct_flag, recovered_key);
    std::cout << "[Attacker] Decrypted flag: 0x" << std::hex << decrypted << "\n";

    return 0;
}
